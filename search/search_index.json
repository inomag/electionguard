{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is ElectionGuard? ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits using ElectionGuard as a secure publishing platform. New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go. Open-Source This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard. Security Issues Reporting We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process. Contributing Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there. Questions ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com . Thank you A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"What is ElectionGuard?"},{"location":"#_1","text":"","title":""},{"location":"#what-is-electionguard","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits using ElectionGuard as a secure publishing platform. New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go.","title":"What is ElectionGuard?"},{"location":"#open-source","text":"This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.","title":"Open-Source"},{"location":"#security-issues-reporting","text":"We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.","title":"Security Issues Reporting"},{"location":"#contributing","text":"Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there.","title":"Contributing"},{"location":"#questions","text":"ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com .","title":"Questions"},{"location":"#thank-you","text":"A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Thank you"},{"location":"basics/Introduction/","text":"","title":"Introduction"},{"location":"basics/steps/0_Configure_Election/","text":"Configure Election Manifest An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots. Guardians A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#configure-election","text":"","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#manifest","text":"An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots.","title":"Manifest"},{"location":"basics/steps/0_Configure_Election/#guardians","text":"A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Guardians"},{"location":"basics/steps/1_Key_Ceremony/","text":"Key Ceremony The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election. Summary The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election. Attendance Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance. Key Sharing Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received. Joint Key The final step is to publish the joint election key after all keys and backups have been shared.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#key-ceremony","text":"The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#summary","text":"The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election.","title":"Summary"},{"location":"basics/steps/1_Key_Ceremony/#attendance","text":"Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance.","title":"Attendance"},{"location":"basics/steps/1_Key_Ceremony/#key-sharing","text":"Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received.","title":"Key Sharing"},{"location":"basics/steps/1_Key_Ceremony/#joint-key","text":"The final step is to publish the joint election key after all keys and backups have been shared.","title":"Joint Key"},{"location":"basics/steps/2_Encryption/","text":"Encryption The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/2_Encryption/#encryption","text":"The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/3_Cast_and_Challenge/","text":"Cast and Challenge Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/3_Cast_and_Challenge/#cast-and-challenge","text":"Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/4_Decryption/","text":"Decryption At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/4_Decryption/#decryption","text":"At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/5_Publish_Record/","text":"Publish Record Publishing the election artifacts helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election artifacts. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/5_Publish_Record/#publish-record","text":"Publishing the election artifacts helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election artifacts. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/6_Verification/","text":"Verification Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"basics/steps/6_Verification/#verification","text":"Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"concepts/Homomorphic_Aggregation/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Aggregation"},{"location":"concepts/Homomorphic_Aggregation/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Homomorphic_Encryption/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Encryption"},{"location":"concepts/Homomorphic_Encryption/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Manifest_Building/","text":"Election Manifest There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ] Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Building"},{"location":"concepts/Manifest_Building/#election-manifest","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Election Manifest"},{"location":"concepts/Manifest_Building/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"concepts/Manifest_Building/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"concepts/Manifest_Building/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"concepts/Manifest_Building/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"concepts/Manifest_Building/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"concepts/Manifest_Building/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ]","title":"Geographic Jurisdictions"},{"location":"concepts/Manifest_Building/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"concepts/Manifest_Building/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"concepts/Manifest_Building/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"concepts/Manifest_Building/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"concepts/Manifest_Building/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"concepts/Manifest_Building/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"concepts/Manifest_Example/","text":"Manifest Example Work in Progress This is a work in progress. Feel free to contribute.","title":"Example"},{"location":"concepts/Manifest_Example/#manifest-example","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Manifest Example"},{"location":"concepts/Verifiability/","text":"Creating a Verifiable Election ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below. Voter Verification Code A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system. Generating the Verification Code Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly). Challenging a ballot Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct. Publishing Verifiable results When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct. Showing Verification Code Results to Voters In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Introduction"},{"location":"concepts/Verifiability/#creating-a-verifiable-election","text":"ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below.","title":"Creating a Verifiable Election"},{"location":"concepts/Verifiability/#voter-verification-code","text":"A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system.","title":"Voter Verification Code"},{"location":"concepts/Verifiability/#generating-the-verification-code","text":"Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).","title":"Generating the Verification Code"},{"location":"concepts/Verifiability/#challenging-a-ballot","text":"Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.","title":"Challenging a ballot"},{"location":"concepts/Verifiability/#publishing-verifiable-results","text":"When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.","title":"Publishing Verifiable results"},{"location":"concepts/Verifiability/#showing-verification-code-results-to-voters","text":"In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Showing Verification Code Results to Voters"},{"location":"concepts/Verifier/","text":"","title":"Verifier"},{"location":"concepts/Voter_Verification/","text":"","title":"Voter"},{"location":"contribute/","text":"Contribute Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard. Where to Start? There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI Ways to get involved Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images . Contributions ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election. Verifiers Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher Library Ports Java port of Python Library by John Caron","title":"Contribute"},{"location":"contribute/#contribute","text":"Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard.","title":"Contribute"},{"location":"contribute/#where-to-start","text":"There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI","title":"Where to Start?"},{"location":"contribute/#ways-to-get-involved","text":"Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images .","title":"Ways to get involved"},{"location":"contribute/#contributions","text":"ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election.","title":"Contributions"},{"location":"contribute/#verifiers","text":"Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher","title":"Verifiers"},{"location":"contribute/#library-ports","text":"Java port of Python Library by John Caron","title":"Library Ports"},{"location":"develop/Getting_Started/","text":"Getting Started If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following repositories showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you. ElectionGuard Specification The ElectionGuard Specification repo addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. ElectionGuard Specification ElectionGuard Python The ElectionGuard Python library is the reference implementation of the ElectionGuard SDK. It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a java port . ElectionGuard C++ The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source","title":"Getting Started"},{"location":"develop/Getting_Started/#getting-started","text":"If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following repositories showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you.","title":"Getting Started"},{"location":"develop/Getting_Started/#electionguard-specification","text":"The ElectionGuard Specification repo addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. ElectionGuard Specification","title":"ElectionGuard Specification  "},{"location":"develop/Getting_Started/#electionguard-python","text":"The ElectionGuard Python library is the reference implementation of the ElectionGuard SDK. It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a java port .","title":"ElectionGuard Python  "},{"location":"develop/Getting_Started/#electionguard-c","text":"The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source","title":"ElectionGuard C++  "},{"location":"develop/Repositories/","text":"Repositories The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI Diagrams flowchart TD subgraph \"Repositories\" spec[\"electionguard\"] -.-> |python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; pypi --> web-api[\"electionguard-api-python\"]; e-python --> |pypi|pypi[\"python module: electionguard\"]:::package; web-api --> e-ui[\"electionguard-ui\"]; e-cpp --> |nuget| nuget[\"ElectionGuard.Encryption\"]:::package; end subgraph \"Overview\" specification -.-> |python|python[\"core\"]; specification -.-> |C++|cpp[\"encryption\"]; python --> |pypi|module:::package module --> api[\"web-api\"]; api --> ui[\"user interface\"]; cpp --> |nuget|package:::package end classDef package fill: teal, stroke: black;","title":"Repositories"},{"location":"develop/Repositories/#repositories","text":"The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI","title":"Repositories"},{"location":"develop/Repositories/#diagrams","text":"flowchart TD subgraph \"Repositories\" spec[\"electionguard\"] -.-> |python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; pypi --> web-api[\"electionguard-api-python\"]; e-python --> |pypi|pypi[\"python module: electionguard\"]:::package; web-api --> e-ui[\"electionguard-ui\"]; e-cpp --> |nuget| nuget[\"ElectionGuard.Encryption\"]:::package; end subgraph \"Overview\" specification -.-> |python|python[\"core\"]; specification -.-> |C++|cpp[\"encryption\"]; python --> |pypi|module:::package module --> api[\"web-api\"]; api --> ui[\"user interface\"]; cpp --> |nuget|package:::package end classDef package fill: teal, stroke: black;","title":"Diagrams"},{"location":"develop/Sample_Data/","text":"Sample Data To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers. Four Sample Elections We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation . Election Manifests The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full | hamilton Submitted Ballots Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full | hamilton Artifacts Election Artifacts are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the artifacts. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full | hamilton","title":"Sample Data"},{"location":"develop/Sample_Data/#sample-data","text":"To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers.","title":"Sample Data"},{"location":"develop/Sample_Data/#four-sample-elections","text":"We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation .","title":"Four Sample Elections"},{"location":"develop/Sample_Data/#election-manifests","text":"The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full | hamilton","title":"Election Manifests"},{"location":"develop/Sample_Data/#submitted-ballots","text":"Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full | hamilton","title":"Submitted Ballots"},{"location":"develop/Sample_Data/#artifacts","text":"Election Artifacts are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the artifacts. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full | hamilton","title":"Artifacts"},{"location":"overview/Features/","text":"Features Work in Progress This is a work in progress. Feel free to contribute.","title":"Features"},{"location":"overview/Features/#features","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Features"},{"location":"overview/Glossary/","text":"ElectionGuard Glossary Overview Software development kits (SDKs) such as ElectionGuard, by their very nature, are intended to stitch together multiple distinct actions or areas into a cohesive whole. By necessity an SDK must \"speak\" multiple languages so the different actors involved can understand how the SDK fits in their world. This Glossary attempts to address its different audiences with terms and constructs appropriate to each: for election administrators, terms that map to their conception of the voting process and user experience; for developers, efficient constructs and a grammar that conveys the appropriate action to be performed and the proper state of the entity they're working with; for cryptographers and verifier contributors, consistency of usage between the specification and code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of all election artifacts and processes; and for everyone, clear articulation of the meaning and rationale for the different facets of end-to-end verifiability To illustrate what that means in practice, take one of the fundamental tenets of end-to-end verifiability: spoiling , challenging , or decrypting a ballot. Each of these words can mean the same thing sometimes but not always; it depends on the context of the usage. So in this example: Spoiling a ballot is a process election administrators use to allow voters who make mistakes filling out a ballot to begin again with a replacement ballot; in this context, the spoil process is a physical process undertaken by poll workers to ensure the ballot with a mistake is not included in any tallies. Challenging a ballot is the process voters use to challenge the integrity of the voting system by forcing it to reveal what it would have submitted if the ballot were actually cast; challenged ballots are published in their unencrypted (original, human-readable) state Decrypting a ballot is the process developers use to reveal a ballot's unencrypted contents; election guardians decrypt challenge ballots as part of the publishing process for end-to-end-verifiable elections . Info Whenever possible, we used terms and meanings consistent the NIST Elections Guide . Terms accepted ballot A ballot that is accepted for inclusion in election results and is either: cast or spoiled. auxiliary key pair Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians. Auxiliary key pairs are used available guardian A guardian that has announced as present for the decryption phase ballot box A collection of ballots that have been either cast or spoiled. ballot chain ballot encryption (see encrypting a ballot ) ballot lifecycle base hash \\(Q\\) Represented as \\(Q\\) , the base hash is the hash of the election cast ballot A ballot which a voter has accepted as valid to be included in the official election tally. challenge ballot ciphertext ballot An encrypted representation of a voter's filled-in ballot. ciphertext election context The cryptographic context of an election that is configured during the Key Ceremony code (see verification code ) Info Code has many meanings. Code can refer to the Python and C++ repos. Code can also mean code the noun (\"I'm going to look at the code\") and verb (\"I'm going to go code\") generally. Context matters Code in the ElectionGuard context refers to the verification code generated by the ballot encryption process. That is code in the code libraries themselves is the hexadecimal string generated by the ballot encryption process. compact ballot compensated decryption share A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. contest A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version.2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. decrypting a ballot A graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot) decrypting a tally graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally) decryption mediator A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally decryption share A guardian's partial share of a decryption description hash ( preferred: base hash ) A hash representation of the original election description election election description The election description is the election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. A subset of this data, the manifest is encrypted with the joint public key generated by the key ceremony conducted by the election guardians to generate the extended base hash that will be used to uniquely associate an encrypted ballot with a specific election. election guardian One of a number of independent, trustworthy individuals who as part of serving as an election guardian in an end-to-end verifiable election participate in a key ceremony to create a joint public election key and perform a tally election manifest (see manifest ) election partial key backup A point on a secret polynomial and commitments to verify this point for a designated guardian. election polynomial The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. encrypt encrypted ballot metadata A specific subset of election metadata encrypted tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. encrypting a ballot As outlined in the ElectionGuard Specification graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) encryption device The device that is doing the encryption end-to-end-verifiable election An election is end-to-end verifiable 1 if: Cast as intended -- voters can verify that their own selections have been correctly recorded. Counted as cast -- anyone can verify that the recorded votes have been correctly tallied. extended base hash \\(\\overline{Q}\\) graph LR A[joint public key] --> C>extended base hash]; B[manifest] --> C; guardian (see election guardian ) hardware security module (hsm) hash Hashing is a common practice in computing; ElectionGuard uses hashing in its cryptographic context , a mechanism to map data of an arbitrary size into a fixed-size equivalent. This is done for a variety of reasons, including preventing discovery of election ballot contents. internal election description Deprecated this term is deprecated and replaced with manifest The subset of the election description required by ElectionGuard and combined with the joint public key to create the extended base hash used at the instantiation of the encrypted ballot ballot chain ballots are correctly associated with an election. This component mutates the state of the Election Description. joint public key Combined public key generated by the key ceremony of the election guardians. Each election guardian creates their own public-private key pair and shares the public key with the other guardians. The output of the ceremony is the joint public key used by voting devices to encrypt ballots . graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[election guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[election guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[election guardian n] c1(private key) -.- c2(public key) end Creating a joint public key as part of the key ceremony key ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. key ceremony mediator A mediator to mediate communication (if needed) of information such as keys between the guardians key pair A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . In ElectionGuard, each election guardian that is part of an election creates a public-private key pair and shares their private key with the other election guardians as part of the key ceremony graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end manifest The manifest is a subset of the election description that uniquely specifies an election. It is combined with the joint public key to create the extended base hash used to instantiate a voting device to encrypt ballots master nonce A mediator to mediate communication (if needed) of information such as keys between the guardians missing guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. nonce A random number used to derive encryptions NIZK (see non-interactive-zero-knowledge proof ) non-interactive-zero-knowledge proof A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value \\(x\\) , without conveying any information apart from the fact that they know the value \\(x\\) . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover. ElectionGuard uses four different types of NIZK to enable ElectionGuard to demonstrate: keys are properly chosen ballots are properly formed decryptions match claimed values plaintext ballot The plaintext representation of a voter's selections post-election audit A post-election audit is \\(Q\\) --see Base hash The base hash is the hash of the election manifest metadata \\(\\overline{Q}\\) --see Extended base hash quorum The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. spoiled ballot A spoiled ballot is an election term that refers to a ballot that, typically due to a mistake, allows a voter to turn in their ballot and instead submit a replacement ballot as their official cast ballot . In this context, spoiling is the process election administrators use to make sure this ballot is not included in the election tally. Ballot spoiling is used in end-to-end verifiability as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. Because the ballot will not be used in the official tally, its contents can be revealed. And because the spoil process happens after ballot encryption, the machine cannot modify the encrypted ballot retrospectively without revealing its attempt. submitted ballot A submitted ballot is an encrypted ballot that has been cast or spoiled graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2 tally ceremony undervote An undervote in a contest or election unknown ballot An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results. verification code A unique hash value generated by an Encryption Device to anonymously identify a ballot See also End-to-end Verifiability \u21a9 From Wikipedia ( Zero-Knowledge Proof \u21a9","title":"Glossary"},{"location":"overview/Glossary/#electionguard-glossary","text":"","title":"ElectionGuard Glossary"},{"location":"overview/Glossary/#overview","text":"Software development kits (SDKs) such as ElectionGuard, by their very nature, are intended to stitch together multiple distinct actions or areas into a cohesive whole. By necessity an SDK must \"speak\" multiple languages so the different actors involved can understand how the SDK fits in their world. This Glossary attempts to address its different audiences with terms and constructs appropriate to each: for election administrators, terms that map to their conception of the voting process and user experience; for developers, efficient constructs and a grammar that conveys the appropriate action to be performed and the proper state of the entity they're working with; for cryptographers and verifier contributors, consistency of usage between the specification and code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of all election artifacts and processes; and for everyone, clear articulation of the meaning and rationale for the different facets of end-to-end verifiability To illustrate what that means in practice, take one of the fundamental tenets of end-to-end verifiability: spoiling , challenging , or decrypting a ballot. Each of these words can mean the same thing sometimes but not always; it depends on the context of the usage. So in this example: Spoiling a ballot is a process election administrators use to allow voters who make mistakes filling out a ballot to begin again with a replacement ballot; in this context, the spoil process is a physical process undertaken by poll workers to ensure the ballot with a mistake is not included in any tallies. Challenging a ballot is the process voters use to challenge the integrity of the voting system by forcing it to reveal what it would have submitted if the ballot were actually cast; challenged ballots are published in their unencrypted (original, human-readable) state Decrypting a ballot is the process developers use to reveal a ballot's unencrypted contents; election guardians decrypt challenge ballots as part of the publishing process for end-to-end-verifiable elections . Info Whenever possible, we used terms and meanings consistent the NIST Elections Guide .","title":"Overview"},{"location":"overview/Glossary/#terms","text":"","title":"Terms"},{"location":"overview/Glossary/#accepted-ballot","text":"A ballot that is accepted for inclusion in election results and is either: cast or spoiled.","title":"accepted ballot"},{"location":"overview/Glossary/#auxiliary-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians. Auxiliary key pairs are used","title":"auxiliary key pair"},{"location":"overview/Glossary/#available-guardian","text":"A guardian that has announced as present for the decryption phase","title":"available guardian"},{"location":"overview/Glossary/#ballot-box","text":"A collection of ballots that have been either cast or spoiled.","title":"ballot box"},{"location":"overview/Glossary/#ballot-chain","text":"","title":"ballot chain"},{"location":"overview/Glossary/#ballot-encryption-see-encrypting-a-ballot","text":"","title":"ballot encryption (see encrypting a ballot )"},{"location":"overview/Glossary/#ballot-lifecycle","text":"","title":"ballot lifecycle"},{"location":"overview/Glossary/#base-hash-q","text":"Represented as \\(Q\\) , the base hash is the hash of the election","title":"base hash \\(Q\\)"},{"location":"overview/Glossary/#cast-ballot","text":"A ballot which a voter has accepted as valid to be included in the official election tally.","title":"cast ballot"},{"location":"overview/Glossary/#challenge-ballot","text":"","title":"challenge ballot"},{"location":"overview/Glossary/#ciphertext-ballot","text":"An encrypted representation of a voter's filled-in ballot.","title":"ciphertext ballot"},{"location":"overview/Glossary/#ciphertext-election-context","text":"The cryptographic context of an election that is configured during the Key Ceremony","title":"ciphertext election context"},{"location":"overview/Glossary/#code-see-verification-code","text":"Info Code has many meanings. Code can refer to the Python and C++ repos. Code can also mean code the noun (\"I'm going to look at the code\") and verb (\"I'm going to go code\") generally. Context matters Code in the ElectionGuard context refers to the verification code generated by the ballot encryption process. That is code in the code libraries themselves is the hexadecimal string generated by the ballot encryption process.","title":"code (see verification code)"},{"location":"overview/Glossary/#compact-ballot","text":"","title":"compact ballot"},{"location":"overview/Glossary/#compensated-decryption-share","text":"A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted.","title":"compensated decryption share"},{"location":"overview/Glossary/#contest","text":"A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version.2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest.","title":"contest"},{"location":"overview/Glossary/#decrypting-a-ballot","text":"A graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot)","title":"decrypting a ballot"},{"location":"overview/Glossary/#decrypting-a-tally","text":"graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally)","title":"decrypting a tally"},{"location":"overview/Glossary/#decryption-mediator","text":"A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally","title":"decryption mediator"},{"location":"overview/Glossary/#decryption-share","text":"A guardian's partial share of a decryption","title":"decryption share"},{"location":"overview/Glossary/#description-hash-preferred-base-hash","text":"A hash representation of the original election description","title":"description hash (preferred: base hash)"},{"location":"overview/Glossary/#election","text":"","title":"election"},{"location":"overview/Glossary/#election-description","text":"The election description is the election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. A subset of this data, the manifest is encrypted with the joint public key generated by the key ceremony conducted by the election guardians to generate the extended base hash that will be used to uniquely associate an encrypted ballot with a specific election.","title":"election description"},{"location":"overview/Glossary/#election-guardian","text":"One of a number of independent, trustworthy individuals who as part of serving as an election guardian in an end-to-end verifiable election participate in a key ceremony to create a joint public election key and perform a tally","title":"election guardian"},{"location":"overview/Glossary/#election-manifest-see-manifest","text":"","title":"election manifest (see manifest)"},{"location":"overview/Glossary/#election-partial-key-backup","text":"A point on a secret polynomial and commitments to verify this point for a designated guardian.","title":"election partial key backup"},{"location":"overview/Glossary/#election-polynomial","text":"The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key.","title":"election polynomial"},{"location":"overview/Glossary/#encrypt","text":"","title":"encrypt"},{"location":"overview/Glossary/#encrypted-ballot-metadata","text":"A specific subset of election metadata","title":"encrypted ballot metadata"},{"location":"overview/Glossary/#encrypted-tally","text":"The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election.","title":"encrypted tally"},{"location":"overview/Glossary/#encrypting-a-ballot","text":"As outlined in the ElectionGuard Specification graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot)","title":"encrypting a ballot"},{"location":"overview/Glossary/#encryption-device","text":"The device that is doing the encryption","title":"encryption device"},{"location":"overview/Glossary/#end-to-end-verifiable-election","text":"An election is end-to-end verifiable 1 if: Cast as intended -- voters can verify that their own selections have been correctly recorded. Counted as cast -- anyone can verify that the recorded votes have been correctly tallied.","title":"end-to-end-verifiable election"},{"location":"overview/Glossary/#extended-base-hash-overlineq","text":"graph LR A[joint public key] --> C>extended base hash]; B[manifest] --> C;","title":"extended base hash \\(\\overline{Q}\\)"},{"location":"overview/Glossary/#guardian-see-election-guardian","text":"","title":"guardian (see election guardian)"},{"location":"overview/Glossary/#hardware-security-module-hsm","text":"","title":"hardware security module (hsm)"},{"location":"overview/Glossary/#hash","text":"Hashing is a common practice in computing; ElectionGuard uses hashing in its cryptographic context , a mechanism to map data of an arbitrary size into a fixed-size equivalent. This is done for a variety of reasons, including preventing discovery of election ballot contents.","title":"hash"},{"location":"overview/Glossary/#internal-election-description","text":"Deprecated this term is deprecated and replaced with manifest The subset of the election description required by ElectionGuard and combined with the joint public key to create the extended base hash used at the instantiation of the encrypted ballot ballot chain ballots are correctly associated with an election. This component mutates the state of the Election Description.","title":"internal election description"},{"location":"overview/Glossary/#joint-public-key","text":"Combined public key generated by the key ceremony of the election guardians. Each election guardian creates their own public-private key pair and shares the public key with the other guardians. The output of the ceremony is the joint public key used by voting devices to encrypt ballots . graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[election guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[election guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[election guardian n] c1(private key) -.- c2(public key) end Creating a joint public key as part of the key ceremony","title":"joint public key"},{"location":"overview/Glossary/#key-ceremony","text":"The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election.","title":"key ceremony"},{"location":"overview/Glossary/#key-ceremony-mediator","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"key ceremony mediator"},{"location":"overview/Glossary/#key-pair","text":"A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . In ElectionGuard, each election guardian that is part of an election creates a public-private key pair and shares their private key with the other election guardians as part of the key ceremony graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end","title":"key pair"},{"location":"overview/Glossary/#manifest","text":"The manifest is a subset of the election description that uniquely specifies an election. It is combined with the joint public key to create the extended base hash used to instantiate a voting device to encrypt ballots","title":"manifest"},{"location":"overview/Glossary/#master-nonce","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"master nonce"},{"location":"overview/Glossary/#missing-guardian","text":"A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results.","title":"missing guardian"},{"location":"overview/Glossary/#nonce","text":"A random number used to derive encryptions","title":"nonce"},{"location":"overview/Glossary/#nizk-see-non-interactive-zero-knowledge-proof","text":"","title":"NIZK (see non-interactive-zero-knowledge proof)"},{"location":"overview/Glossary/#non-interactive-zero-knowledge-proof","text":"A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value \\(x\\) , without conveying any information apart from the fact that they know the value \\(x\\) . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover. ElectionGuard uses four different types of NIZK to enable ElectionGuard to demonstrate: keys are properly chosen ballots are properly formed decryptions match claimed values","title":"non-interactive-zero-knowledge proof"},{"location":"overview/Glossary/#plaintext-ballot","text":"The plaintext representation of a voter's selections","title":"plaintext ballot"},{"location":"overview/Glossary/#post-election-audit","text":"A post-election audit is","title":"post-election audit"},{"location":"overview/Glossary/#q-see-base-hash","text":"The base hash is the hash of the election manifest metadata","title":"\\(Q\\) --see Base hash"},{"location":"overview/Glossary/#overlineq-see-extended-base-hash","text":"","title":"\\(\\overline{Q}\\) --see Extended base hash"},{"location":"overview/Glossary/#quorum","text":"The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results.","title":"quorum"},{"location":"overview/Glossary/#spoiled-ballot","text":"A spoiled ballot is an election term that refers to a ballot that, typically due to a mistake, allows a voter to turn in their ballot and instead submit a replacement ballot as their official cast ballot . In this context, spoiling is the process election administrators use to make sure this ballot is not included in the election tally. Ballot spoiling is used in end-to-end verifiability as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. Because the ballot will not be used in the official tally, its contents can be revealed. And because the spoil process happens after ballot encryption, the machine cannot modify the encrypted ballot retrospectively without revealing its attempt.","title":"spoiled ballot"},{"location":"overview/Glossary/#submitted-ballot","text":"A submitted ballot is an encrypted ballot that has been cast or spoiled graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2","title":"submitted ballot"},{"location":"overview/Glossary/#tally-ceremony","text":"","title":"tally ceremony"},{"location":"overview/Glossary/#undervote","text":"An undervote in a contest or election","title":"undervote"},{"location":"overview/Glossary/#unknown-ballot","text":"An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results.","title":"unknown ballot"},{"location":"overview/Glossary/#verification-code","text":"A unique hash value generated by an Encryption Device to anonymously identify a ballot See also End-to-end Verifiability \u21a9 From Wikipedia ( Zero-Knowledge Proof \u21a9","title":"verification code"},{"location":"overview/Principles/","text":"Principles Work in Progress This is a work in progress. Feel free to contribute.","title":"Principles"},{"location":"overview/Principles/#principles","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Principles"},{"location":"overview/Roadmap/","text":"ElectionGuard Roadmap 2021 Roadmap The 2021 roadmap takes the learnings from the different applications deployed in 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api 2020 In Review 2020 taught many lessons. The first half of the year saw a successful Fulton, WI Election Pilot with VotingWorks and InfernoRed . Subsequent to the election the Python repo was released as a new reference implementation. In the second half of the year , responding to COVID led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, the first independent verifiers were developed and published . 2020 Roadmap Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools 2019 Roadmap Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"Roadmap"},{"location":"overview/Roadmap/#electionguard-roadmap","text":"","title":"ElectionGuard Roadmap"},{"location":"overview/Roadmap/#2021-roadmap","text":"The 2021 roadmap takes the learnings from the different applications deployed in 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api","title":"2021 Roadmap"},{"location":"overview/Roadmap/#2020-in-review","text":"2020 taught many lessons. The first half of the year saw a successful Fulton, WI Election Pilot with VotingWorks and InfernoRed . Subsequent to the election the Python repo was released as a new reference implementation. In the second half of the year , responding to COVID led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, the first independent verifiers were developed and published .","title":"2020 In Review"},{"location":"overview/Roadmap/#2020-roadmap","text":"Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools","title":"2020 Roadmap"},{"location":"overview/Roadmap/#2019-roadmap","text":"Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"2019 Roadmap"},{"location":"spec/Badges/","text":"Badges For your convenience, these are some badges to add to your repository indicating the specification your code supports. [![ElectionGuard Specification 0.85.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.85.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 0.95.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.95.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 1.0.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-1.0.0-yellow)](https://www.electionguard.vote)","title":"Badges"},{"location":"spec/Badges/#badges","text":"For your convenience, these are some badges to add to your repository indicating the specification your code supports. [![ElectionGuard Specification 0.85.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.85.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 0.95.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-0.95.0-green)](https://www.electionguard.vote) [![ElectionGuard Specification 1.0.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard%20Specification-1.0.0-yellow)](https://www.electionguard.vote)","title":"Badges"},{"location":"spec/Data_Format/","text":"Data Format Work in Progress This is a work in progress. Feel free to contribute.","title":"Data Format"},{"location":"spec/Data_Format/#data-format","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Data Format"},{"location":"spec/0.85.0/1_Overview/","text":"ElectionGuard Specification Download Specification No web version of this specification is available at this time. Download specification here","title":"v0.85.0"},{"location":"spec/0.85.0/1_Overview/#electionguard-specification","text":"Download Specification No web version of this specification is available at this time. Download specification here","title":"ElectionGuard Specification"},{"location":"spec/0.95.0/1_Overview/","text":"ElectionGuard Specification Download Specification No web version of this specification is available at this time. Download specification here .","title":"v0.95.0"},{"location":"spec/0.95.0/1_Overview/#electionguard-specification","text":"Download Specification No web version of this specification is available at this time. Download specification here .","title":"ElectionGuard Specification"},{"location":"spec/1.0.0/1_Overview/","text":"ElectionGuard Specification Under Development This version is unreleased. Star the repository and follow along for updates.","title":"v1.0.0"},{"location":"spec/1.0.0/1_Overview/#electionguard-specification","text":"Under Development This version is unreleased. Star the repository and follow along for updates.","title":"ElectionGuard Specification"},{"location":"use_cases/Audit/","text":"Audit Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Audit/#audit","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Electronic_Delivery/","text":"Electronic Delivery Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Electronic_Delivery/#electronic-delivery","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Mail_In/","text":"Mail In Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Mail_In/#mail-in","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Precinct_Scan/","text":"Precinct Scan Work in Progress This is a work in progress. Feel free to contribute. Overview By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election artifacts have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice. Current Precinct Scan Voter Experience A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter. Adapting Precinct Scan for End-to-end Verifiability (E2E-V) Voter Experience As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot Technical Requirements For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments. Technical Implementation Overview and Operational Assumptions Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.) General Election Setup Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election. Ballot manifest Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well. Public encryption key One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of election artifacts. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The Logic and Accuracy Testing Scanner Final Production Setup Launch Code Scanner Election Operation Ballot Encryption Generation of Verification Code Ballot Chaining Ballot Dehydration Dehydrated ballot structure A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process Ballot Finalization Cast ballots Challenge ballots As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#precinct-scan","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#overview","text":"By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election artifacts have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice.","title":"Overview"},{"location":"use_cases/Precinct_Scan/#current-precinct-scan-voter-experience","text":"A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter.","title":"Current Precinct Scan Voter Experience"},{"location":"use_cases/Precinct_Scan/#adapting-precinct-scan-for-end-to-end-verifiability-e2e-v","text":"","title":"Adapting Precinct Scan for End-to-end Verifiability (E2E-V)"},{"location":"use_cases/Precinct_Scan/#voter-experience","text":"As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot","title":"Voter Experience"},{"location":"use_cases/Precinct_Scan/#technical-requirements","text":"For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments.","title":"Technical Requirements"},{"location":"use_cases/Precinct_Scan/#technical-implementation","text":"","title":"Technical Implementation"},{"location":"use_cases/Precinct_Scan/#overview-and-operational-assumptions","text":"Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.)","title":"Overview and Operational Assumptions"},{"location":"use_cases/Precinct_Scan/#general-election-setup","text":"Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election.","title":"General Election Setup"},{"location":"use_cases/Precinct_Scan/#ballot-manifest","text":"Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well.","title":"Ballot manifest"},{"location":"use_cases/Precinct_Scan/#public-encryption-key","text":"One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of election artifacts. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The","title":"Public encryption key"},{"location":"use_cases/Precinct_Scan/#logic-and-accuracy-testing","text":"","title":"Logic and Accuracy Testing"},{"location":"use_cases/Precinct_Scan/#scanner-final-production-setup","text":"","title":"Scanner Final Production Setup"},{"location":"use_cases/Precinct_Scan/#launch-code","text":"","title":"Launch Code"},{"location":"use_cases/Precinct_Scan/#scanner-election-operation","text":"","title":"Scanner Election Operation"},{"location":"use_cases/Precinct_Scan/#ballot-encryption","text":"","title":"Ballot Encryption"},{"location":"use_cases/Precinct_Scan/#generation-of-verification-code","text":"","title":"Generation of Verification Code"},{"location":"use_cases/Precinct_Scan/#ballot-chaining","text":"","title":"Ballot Chaining"},{"location":"use_cases/Precinct_Scan/#ballot-dehydration","text":"","title":"Ballot Dehydration"},{"location":"use_cases/Precinct_Scan/#dehydrated-ballot-structure","text":"A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process","title":"Dehydrated ballot structure"},{"location":"use_cases/Precinct_Scan/#ballot-finalization","text":"","title":"Ballot Finalization"},{"location":"use_cases/Precinct_Scan/#cast-ballots","text":"","title":"Cast ballots"},{"location":"use_cases/Precinct_Scan/#challenge-ballots","text":"As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Challenge ballots"},{"location":"use_cases/Rescans_and_Recounts/","text":"Rescans and Recounts Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status. Overview In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata. Proposed Approach To maintain the security and integrity of the original election artifacts, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping. Encrypting a Unique Ballot ID Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies Diffing an Election Invoking a Rescan or Recount After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed. Optimizing the Compute Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#rescans-and-recounts","text":"Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status.","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#overview","text":"In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata.","title":"Overview"},{"location":"use_cases/Rescans_and_Recounts/#proposed-approach","text":"To maintain the security and integrity of the original election artifacts, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping.","title":"Proposed Approach"},{"location":"use_cases/Rescans_and_Recounts/#encrypting-a-unique-ballot-id","text":"Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies","title":"Encrypting a Unique Ballot ID"},{"location":"use_cases/Rescans_and_Recounts/#diffing-an-election","text":"","title":"Diffing an Election"},{"location":"use_cases/Rescans_and_Recounts/#invoking-a-rescan-or-recount","text":"After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed.","title":"Invoking a Rescan or Recount"},{"location":"use_cases/Rescans_and_Recounts/#optimizing-the-compute","text":"Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Optimizing the Compute"}]}